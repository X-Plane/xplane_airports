from contextlib import suppress
from dataclasses import dataclass, field
from operator import attrgetter
import re
import os
from enum import Enum
from typing import List

WED_LINE_ENDING = '\n'

class RunwayType(Enum):
    LAND_RUNWAY = 100
    WATER_RUNWAY = 101
    HELIPAD = 102


class AptDatLine:
    def __init__(self, line_text):
        """
        @type line_text: str
        """
        self.raw = line_text
        self.row_code = self.raw.strip().split(' ')[0]
        with suppress(ValueError):
            self.row_code = int(self.row_code)

    def is_runway(self):
        return self.row_code in [100, 101, 102]

    def is_ignorable(self):
        return self.row_code == 99 or self.is_file_header() or not self.raw.strip()

    def is_airport_header(self):
        return self.row_code in [1, 16, 17]

    def is_file_header(self):
        return self.row_code in ['I', 'A'] or "Generated by WorldEditor" in self.raw

    @property
    def runway_type(self):
        assert self.is_runway()
        return RunwayType(self.row_code)

    @property
    def components(self):
        return str(self).split(' ')

    def __str__(self):
        return re.sub(' +', ' ', self.raw.strip())  # Strip, and replace multiple spaces with a single

    def __bool__(self):
        return not self.is_ignorable()


@dataclass
class Airport:
    name: str
    id: str
    from_file: str = ''
    has_atc: bool = False
    elevation_ft_amsl: float = 0
    latitude: float = 0
    longitude: float = 0
    text: List[AptDatLine] = field(default_factory=list)

    def __bool__(self):
        return bool(self.id)

    def __str__(self):
        return WED_LINE_ENDING.join(line.raw for line in self.text)

    def has_taxiway(self):
        return self.has_row_code([113, 114])

    def has_taxi_route(self):
        return self.has_row_code(1200)

    def has_traffic_flow(self):
        return self.has_row_code(1000)

    def has_ground_routes(self):  # one of: ground truck destination, ground truck parking loc, or taxi route
        return self.has_row_code([1400, 1401, 1200])

    def has_taxiway_sign(self):
        return self.has_row_code(20)

    def has_comm_freq(self):
        return self.has_row_code([50, 51, 52, 53, 54, 55, 56])

    def has_row_code(self, row_code_or_codes):
        """
        @type row_code_or_codes: int|str|collections.Iterable[int]]
        @rtype: bool
        """
        if isinstance(row_code_or_codes, int) or isinstance(row_code_or_codes, str):
            return any(line for line in self.text if line.row_code == row_code_or_codes)
        return any(line for line in self.text if line.row_code in row_code_or_codes)

    @staticmethod
    def from_lines(apt_dat_lines, from_file):
        """
        @type apt_dat_lines: collections.Iterable[AptDatLine]
        @type from_file: str
        @rtype: Airport
        """
        for line in apt_dat_lines:
            if line.is_airport_header():
                name = ' '.join(line.components[5:])
                apt_id = line.components[4]
                out = Airport(name, apt_id, from_file, text=list(apt_dat_lines))
                out.elevation_ft_amsl = float(line.components[1])
                out.has_atc = bool(int(line.components[2]))  # '0' or '1'
            elif line.is_runway() and not out.latitude:  # You damn well better not have a runway line before your apt header!
                if line.runway_type == RunwayType.LAND_RUNWAY:
                    out.latitude = float(line.components[9])
                    out.longitude = float(line.components[10])
                elif line.runway_type == RunwayType.WATER_RUNWAY:
                    out.latitude = float(line.components[4])
                    out.longitude = float(line.components[5])
                elif line.runway_type == RunwayType.HELIPAD:
                    out.latitude = float(line.components[2])
                    out.longitude = float(line.components[3])
        return out


class AptDat:
    """A parser class for X-Plane's gigantic apt.dat files, which may have data on hundreds of airports."""

    def __init__(self, path_to_file=None):
        """
        @param path_to_file Location of the apt.dat (or ICAO.dat) file on disk
        @type path_to_file: str
        """
        self.airports = []
        """:type: list[Airport]"""

        self.path_to_file = path_to_file
        if self.path_to_file:
            with open(self.path_to_file, 'r') as f:
                self._parse_text(f.readlines(), path_to_file)

    @staticmethod
    def from_file_text(apt_dat_file_text, from_file):
        """
        @param apt_dat_file_text: The contents of an apt.dat (or ICAO.dat) file
        @type apt_dat_file_text: str
        @type from_file: str
        """
        return AptDat()._parse_text(apt_dat_file_text, from_file)

    @staticmethod
    def from_structured_data(apt_names, icaos, have_atc=None, elevations_ft_amsl=None, lats=None, lons=None):
        """
        Construct a parser from already-structured data (useful if you're working with airport data that *didn't*
        come from an apt.dat file for some reason
        """
        assert (len(apt_names) == len(icaos))
        have_atc = have_atc or [False] * len(apt_names)
        elevations_ft_amsl = elevations_ft_amsl or [0] * len(apt_names)
        lats = lats or [0] * len(apt_names)
        lons = lons or [0] * len(apt_names)
        out = AptDat()
        out.airports = list(Airport(from_file='', name=name, id=icaos[i], has_atc=have_atc[i], elevation_ft_amsl=elevations_ft_amsl[i], latitude=lats[i], longitude=lons[i])
                            for i, name in enumerate(apt_names))
        return out

    def _parse_text(self, apt_dat_text, from_file):
        if not isinstance(apt_dat_text, list):  # Must be a newline-containing string
            apt_dat_text = apt_dat_text.splitlines()

        apt_lines = []
        for line in (AptDatLine(l) for l in apt_dat_text):
            if line.is_airport_header():
                if apt_lines:  # finish off the previous airport
                    self.airports.append(Airport.from_lines(apt_lines, from_file))
                apt_lines = [line]
            elif not line.is_ignorable():
                apt_lines.append(line)
        if apt_lines:  # finish off the final airport
            self.airports.append(Airport.from_lines(apt_lines, from_file))
        return self

    def sort(self, key='name'):
        """
        By default, we store the airport data in whatever order we read it from the apt.dat file.
        When you call sort, though, we'll ensure that it's in order (default to name order, just like it's always
        been in the shipping versions of X-Plane).
        """
        self.airports = sorted(self.airports, key=attrgetter(key))

    def search_by_id(self, apt_id):
        """
        @type apt_id: str
        @return: Airport|None
        """
        return self.search_by_predicate(lambda apt: apt.id.upper() == apt_id.upper())

    def search_by_name(self, apt_name):
        """
        @type apt_name: str
        @return: Airport|None
        """
        return self.search_by_predicate(lambda apt: apt.name.upper() == apt_name.upper())

    def search_by_predicate(self, predicate_fn):
        """
        @type predicate_fn: (Airport) -> bool
        @return: Airport|None
        """
        for apt in self.airports:
            if predicate_fn(apt):
                return apt
        return None

    @property
    def ids(self):
        return (apt.id for apt in self.airports)

    @property
    def names(self):
        return (apt.name for apt in self.airports)

    def __str__(self):
        return WED_LINE_ENDING.join(str(apt) for apt in self.airports)

    def __getitem__(self, key):
        """
        @param key: int|str
        @return: Airport|None
        """
        if isinstance(key, int) and key < len(self.airports):
            return self.airports[key]
        assert isinstance(key, str)
        for pred in [self.search_by_id, self.search_by_name]:
            result = pred(key)
            if result:
                return result
        return None

    def __repr__(self):
        return str(list(self.ids))

    def __eq__(self, other):
        return self.airports == other.airports

    def __iter__(self):
        return (apt for apt in self.airports)

    def __concat__(self, other):
        """
        Get a new airport data object that combines the airport data in other with the data in this object.
        Note that no de-duplication will occur---it's your job to make sure the two airport data are disjoint.
        @type other AptDat
        @rtype AptDat
        """
        out = AptDat()
        out.airports = list(self.airports) + list(other.airports)
        return out

    def __iconcat__(self, other):
        """
        Add the airport data in other to the data in this object.
        Note that no de-duplication will occur---it's your job to make sure the two airport data are disjoint.
        @type other AptDat
        """
        self.airports += list(other.airports)

    def __add__(self, apt):
        """
        Add the airport data in other to the data in this object.
        Note that no de-duplication will occur---it's your job to make sure the two airport data are disjoint.
        @type apt Airport
        """
        out = AptDat()
        out.airports = self.airports + [apt]
        return out

    def __iadd__(self, apt):
        """
        Add the airport data in other to the data in this object.
        Note that no de-duplication will occur---it's your job to make sure the two airport data are disjoint.
        @type apt Airport
        """
        self.airports.append(apt)
        return self
